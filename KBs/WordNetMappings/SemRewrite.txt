; Semantic Rewriting Rule set
; author: Adam Pease - adam.pease@ipsoft.com
; implements the semantic rewriting of CELT, as described in
;   Pease, A., and Li, J. (2010) Controlled English to Logic Translation. 
;   In Theory and Applications of Ontology, ed. Roberto Poli, 
;   Michael Healy, and Achilles Kameas, Springer, ISBN: 978-90-481-8846-8.
;  This software is released under the GNU Public License
; <http://www.gnu.org/copyleft/gpl.html>.

;; prepositions --------------

;{isCELTclass(?X,Person)} ==> (isCELTclass(?X,Person)).
;{isCELTclass(?X,Time)} ==> (isCELTclass(?X,Time)).
;{isCELTclass(?X,Object)} ==> (isCELTclass(?X,Time)).

prep_at(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (located(?X,?Y)).
prep_in(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (located(?X,?Y)).
prep_on(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (located(?X,?Y)).
prep_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (destination(?X,?Y)).
prep_towards(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (destination(?X,?Y)).
prep_toward(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (destination(?X,?Y)).
prep_to(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (EndFn(?X,?Y)).

prep_at(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (time(?X,?Y)).
prep_in(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (time(?X,?Y)).
prep_on(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (time(?X,?Y)).

prep_for(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Person) ==> (destination(?X,?Y)).
prep_for(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (duration(?X,?Y)).

prep_since(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (starts(?Y,?X)).

prep_through(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (duration(?X,?Y)).
prep_through(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (traverses(?X,?Y)).

prep_with(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Person) ==> (agent(?X,?Y)).
prep_with(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (instrument(?X,?Y)).

prep_across(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (traverses(?X,?Y)).

prep_within(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (properlyFills(?X,?Y)).
prep_into(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (properlyFills(?X,?Y)).

prep_from(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Object) ==> (origin(?X,?Y)).
prep_from(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (BeginFn(?X,?Y)).

prep_until(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (EndFn(?X,?Y)).

prep_after(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (greaterThan(?X,?Y)).
prep_before(?X,?Y), +sumo(?C,?Y), isCELTclass(?C,Time) ==> (lessThan(?X,?Y)).

; prep_according_to
; prep_across_from
; prep_ahead_of
; prep_along_with
; prep_alongside_of
; prep_apart_from
; prep_as_for
; prep_as_from
; prep_as_of
; prep_as_per
; prep_as_to
; prep_aside_from
; prep_away_from
; prep_based_on
; prep_because_of
; prep_close_by
; prep_close_to
; prep_contrary_to
; prep_compared_to
; prep_compared_with
; prep_due_to
; prep_depending_on
; prep_except_for
; prep_exclusive_of
; prep_contrary_to
; prep_followed_by
; prep_inside_of
; prep_instead_of
; prep_irrespective_of
; prep_next_to
; prep_near_to
; prep_off_of
; prep_out_of
; prep_outside_of
; prep_owing_to
; prep_preliminary_to
; prep_preparatory_to
; prep_previous_to
; prep_prior_to
; prep_pursuant_to
; prep_regardless_of
; prep_subsequent_to
; prep_such_as
; prep_thanks_to
; prep_together_with
; prep_by_means_of
; prep_in_accordance_with
; prep_in_addition_to
; prep_in_case_of
; prep_in_front_of(?V,?Y), nsubj(?V,?Z) ==> (orientation(?Z,?Y,InFrontOf)).
; prep_in_lieu_of
; prep_in_place_of
; prep_in_spite_of
; prep_on_account_of
; prep_on_behalf_of
; prep_on_top_of
; prep_with_regard_to

; home downstairs downtown inside outside upstairs uptown

; approval of, awareness of, belief in, concern for, confusion about, desire for
; fondness for, grasp of, hatred of, hope for, interest in, love of
; need for, participation in, reason for, respect for, success in, understanding of
; afraid of, angry at, aware of, capable of, careless about, familiar with
; fond of, happy about, interested in, jealous of, made of, married to
; proud of, similar to, sorry for, sure of, tired of, worried about
; apologize for, ask about, ask for, belong to, bring up, care for, find out
; give up, grow up, look for, look forward to, look up, make up ,pay for
; prepare for, study for, talk about, think about, trust in ,work for, worry about

;; catalog of dependency elements --------------

; adjectival complement
acomp(?P,?Y), +dobj(?P,?O) ==> (attribute(?O,?Y)).

; adverbial clause modifier
; HOL advcl(?X,?Y) ==> 

; adverbial modifier
advmod(?X,?Y) ==> (attribute(?X,?Y)).

; agent - complement of a passive verb
; agent(?X,?Y) ==> (agent(?X,?Y)).

; adjectival modifier
amod(?X,?Y) ==> (attribute(?X,?Y)).

; appositional modifier
appos(?X,?Y) ==> (equals(?X,?Y)).

; auxilliary
aux(has*,?V) ==> (past(?V,?DUMMY)).
aux(may*,?V) ==> (possible(?V,?DUMMY)).
aux(should*,?V) ==> (possible(?V,?DUMMY)).
aux(must*,?V) ==> (possible(?V,?DUMMY)).

; passive auxiliary
; auxpass(?X,?Y), -past(?X,?DUMMY) ==> (past(?X,?DUMMY)).

; coordination

; clausal complement
; HOL

; clausal subject
; HOL

; clausal passive subject
; HOL

; copula
nsubj(?X,?A), cop(?X,?Y), sumo(?C,?X), isSubclassOf(?C,Attribute) ==> (attribute(?X,?Y)).
nsubj(?X,?A), cop(?X,?Y), sumo(?C,?X) ==> (instance(?X,?C)).

nsubjpass(?X,?Y) ==> (patient(?X,?Y)).

; det(?X,What*), sumo(?O,?X)  ==> (instance(?WHAT,?O)).
; det(?X,Which*), sumo(?O,?X)  ==> (instance(?WHICH,?O)).
; det(?X,Some*)
; det(?X,All*)

; discourse element
; ??

dobj(?E,?Y) ==> (patient(?E,?Y)).

; expletive - not needed?

; goes with

; indirect object
iobj(?X,?Y) ==> (patient(?E,?Y)).

; marker
; mwe

; negation modifier
; note this needs to wrap the entire expression
neg(?V,?N), sumo(?C,N) ==> (not(?V,?DUMMY)).
neg(?V,?Y) ==> (not(?X,?DUMMY)).

; noun compound modifier
; noun phrase as adverbial modifer

; nominal subject - copula handles a special case of this
nsubj(?E,?X) ==> (agent(?E,?X)).

nsubjpass(?E,?Y) ==> (patient(?E,?Y)).

quantmod(?X,About*), num(?O,?X) ==> (approximateValue(?X,countid), num(?O,countid)).

num(?O,one*) ==> (num(?O,1)).
num(?O,two*) ==> (num(?O,2)).
num(?O,three*) ==> (num(?O,3)).
num(?O,four*) ==> (num(?O,4)).
num(?O,five*) ==> (num(?O,5)).
num(?O,six*) ==> (num(?O,6)).
num(?O,seven*) ==> (num(?O,7)).
num(?O,eight*) ==> (num(?O,8)).
num(?O,nine*) ==> (num(?O,9)).
num(?O,ten*) ==> (num(?O,10)).
num(?O,eleven*) ==> (num(?O,11)).
num(?O,twelve*) ==> (num(?O,12)).
num(?O,thirteen*) ==> (num(?O,13)).
num(?O,fourteen*) ==> (num(?O,14)).
num(?O,fifteen*) ==> (num(?O,15)).
num(?O,sixteen*) ==> (num(?O,16)).
num(?O,seventeen*) ==> (num(?O,17)).
num(?O,eighteen*) ==> (num(?O,18)).
num(?O,nineteen*) ==> (num(?O,19)).
num(?O,twenty*) ==> (num(?O,20)).

num(?O,?N), +sumo(?C,?O) ==> (instance(?O,Collection), membersType(?O,?C), membersCount(?O,?N)).
; num(?dollars*,?N) ==> (measure(?dollars*,MeasureFn(?N,UnitedStatesDollar))).
; current language doesn't allow functions

; element of compound number

; parataxis

; pcomp - prepositional complement

; pobj - object of a preposition

; poss: possession modifier

poss(?O,?P) ==> (possesses(?O,?P)).

; preconj: preconjunct - can be ignored?

; predet predeterminer
; looks like another quantifier 
predet(?X,?Y) ==> (det(?X,?Y)).

; prep: prepositional modifier

; prepc: prepositional clausal modifier
prepc_without(?X,?Y) ==> (not(?Y,?DUMMY)).

; prt: phrasal verb particle

; punct: punctuation

; quantmod: quantifier phrase modifer
; has to go above

; ref: reference - not in the collapsed model?

; root 

root(?X,?Y) ==> 0.

; tmod: temporal modifier
tmod(?V,?T) ==> (during(?V,?T)).

; vmod: reduced non-finite verbal modifier

; xcomp: open clausal complement

; xsubj controlling subject
;; statives --------------

; agree - ReachingAgreement
; believe - believes Formula
; belong
; concern
; consist
; contain
; depend
; deserve
; disagree
; dislikes
; doubt
; feel
; fit
; hates
nsubj(?P,?A), dobj(?P,?O), +sumo(dislikes,?P) ==> (dislikes(?A,?O)).

; hear
; imagine
; impress
; include
; involve
; know
; like
; love
; matter
; mean
; measure
; mind
; need
; owe
; owns
nsubj(?P,?A), dobj(?P,?O), +sumo(possesses,?P) ==> (possesses(?A,?O)).

; prefer
; promise
; realise
; recognise
; remember
; seem
; sound
; suppose
; surprise
; understand
; want
; weigh
; wish 
; writes
+sumo(?C,?X), isCELTclass(?C,ContentDevelopment) ==> (authors(?A,?X)).

;; WSD: most polysemous

; light - 114
; run - 110
; play - 100
; make - 97
; set - 87
; give - 86
; point - 80
; take - 77
; line - 72
; get - 67
; roll - 65
; good - 63
; mark - 62
; go - 60
; dead - 60

;; -------------------------------

sumo(?O,?X) ==> (instance(?X,?O)).

agent(?X,?Y) ==> {(agent ?X ?Y)}.
approximateValue(?X,?Y) ==> {(approximateValue ?X ?Y)}.
authors(?X,?Y) ==> {(authors ?X ?Y)}.
attribute(?X,?Y) ==> {(attribute ?X ?Y)}.
destination(?X,?Y) ==> {(destination ?X ?Y)}.
dislikes(?X,?Y) ==> {(dislikes ?X ?Y)}.
duration(?X,?Y) ==> {(duration ?X ?Y)}.
greaterThan(?X,?Y) ==> {(greaterThan ?X ?Y)}.
instance(?X,?Y) ==> {(instance ?X ?Y)}.
located(?X,?Y) ==> {(located ?X ?Y)}.
membersType(?X,?Y) ==> {(membersType ?X ?Y)}.
membersCount(?X,?Y) ==> {(membersCount ?X ?Y)}.
lessThan(?X,?Y) ==> {(lessThan ?X ?Y)}.
;orientation(?X,?Y,?Z) ==> {(orientation ?X ?Y ?Z)}.
origin(?X,?Y) ==> {(origin ?X ?Y)}.
patient(?X,?Y) ==> {(patient ?X ?Y)}.
properlyFills(?X,?Y) ==> {(properlyFills ?X ?Y)}.
possesses(?X,?Y) ==> {(possesses ?X ?Y)}.
traverses(?X,?Y) ==> {(traverses ?X ?Y)}.
time(?X,?Y) ==> {(time ?X ?Y)}.

; time TimeMeasure, Process
; person Human, OccupationalRole, SocialRole
; object all others

; mass Substance, Food, and special words such as
;      money/furniture/data/life/beauty/truth/crime/law/education
; count all others
